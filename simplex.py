# -*- coding: utf-8 -*-
"""simplex.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iBEVOJVsTt67wUySXwaIuOYNlYNjoHq1
"""

num_variables = 2

constraints = ['3x_1 + 1x_2 = 3', '4x_1 + 3x_2 >= 6', '1x_1 + 2x_2 <= 4']

obj_func = 'minimize 4x_1 + 1x_2'

from fractions import Fraction
from warnings import warn


class Simplex2(object):
    def __init__(self, num_vars, constraints, objective_function, condition = True):
        self.num_vars = num_vars
        self.constraints = constraints
        self.condition = condition
        self.objective = objective_function[0]
        self.objective_function = objective_function[1]
        self.coeff_matrix, self.r_rows, self.num_s_vars, self.num_r_vars = self.construct_matrix_from_constraints()
        del self.constraints
        self.basic_vars = [0 for i in range(len(self.coeff_matrix))]
        self.phase1()
        r_index = self.num_r_vars + self.num_s_vars

        for i in self.basic_vars:
            if i > r_index:
                raise ValueError("Infeasible solution")

        for i in range(len(self.coeff_matrix)):
            non_r_length = self.num_vars + self.num_s_vars + 1
            length = len(self.coeff_matrix[i])
            while length != non_r_length:
                del self.coeff_matrix[i][non_r_length-1]
                length -= 1

        if 'min' in self.objective.lower():
            self.solution = self.objective_minimize()

        else:
            self.solution = self.objective_maximize()
        self.optimize_val = self.coeff_matrix[0][-1]

    def construct_matrix_from_constraints(self):
        num_s_vars = 0  # number of slack and surplus variables
        num_r_vars = 0  # number of additional variables to balance equality and less than equal to
        for expression in self.constraints:
            if '>=' in expression:
                num_s_vars += 1

            elif '<=' in expression:
                num_s_vars += 1
                num_r_vars += 1

            elif '=' in expression:
                num_r_vars += 1
        total_vars = self.num_vars + num_s_vars + num_r_vars

        coeff_matrix = [[Fraction("0/1") for i in range(total_vars+1)] for j in range(len(self.constraints)+1)]
        s_index = self.num_vars
        r_index = self.num_vars + num_s_vars
        r_rows = [] # stores the non -zero index of r
        for i in range(1, len(self.constraints)+1):
            constraint = self.constraints[i-1].split(' ')

            for j in range(len(constraint)):

                if '_' in constraint[j]:
                    coeff, index = constraint[j].split('_')
                    if constraint[j-1] is '-':
                        coeff_matrix[i][int(index)-1] = Fraction("-" + coeff[:-1] + "/1")
                    else:
                        coeff_matrix[i][int(index)-1] = Fraction(coeff[:-1] + "/1")

                elif constraint[j] == '<=':
                    coeff_matrix[i][s_index] = Fraction("1/1")  # add surplus variable
                    s_index += 1

                elif constraint[j] == '>=':
                    coeff_matrix[i][s_index] = Fraction("-1/1")  # slack variable
                    coeff_matrix[i][r_index] = Fraction("1/1")   # r variable
                    s_index += 1
                    r_index += 1
                    r_rows.append(i)

                elif constraint[j] == '=':
                    coeff_matrix[i][r_index] = Fraction("1/1")  # r variable
                    r_index += 1
                    r_rows.append(i)

            coeff_matrix[i][-1] = Fraction(constraint[-1] + "/1")

        return coeff_matrix, r_rows, num_s_vars, num_r_vars

    def phase1(self):
        # Objective function here is minimize r1+ r2 + r3 + ... + rn
        r_index = self.num_vars + self.num_s_vars
        for i in range(r_index, len(self.coeff_matrix[0])-1):
            self.coeff_matrix[0][i] = Fraction("-1/1")
        coeff_0 = 0
        for i in self.r_rows:
            self.coeff_matrix[0] = self.add_row(self.coeff_matrix[0], self.coeff_matrix[i])
            self.basic_vars[i] = r_index
            r_index += 1
        s_index = self.num_vars
        for i in range(1, len(self.basic_vars)):
            if self.basic_vars[i] == 0:
                self.basic_vars[i] = s_index
                s_index += 1

        # Run the simplex iterations
        key_column = self.max_index(self.coeff_matrix[0])
        condition = self.coeff_matrix[0][key_column] > 0

        while condition is True:

            key_row = self.find_key_row(key_column = key_column)
            self.basic_vars[key_row] = key_column
            pivot = self.coeff_matrix[key_row][key_column]
            self.normalize_to_pivot(key_row, pivot)
            self.make_key_column_zero(key_column, key_row)

            key_column = self.max_index(self.coeff_matrix[0])
            condition = self.coeff_matrix[0][key_column] > 0

    def find_key_row(self, key_column):
        min_val = float("inf")
        min_i = 0
        for i in range(1, len(self.coeff_matrix)):
            if self.coeff_matrix[i][key_column] > 0:
                val = self.coeff_matrix[i][-1] / self.coeff_matrix[i][key_column]
                if val <  min_val:
                    min_val = val
                    min_i = i
        if min_val == float("inf"):
            raise ValueError("Unbounded solution")
        if min_val == 0:
            warn("Dengeneracy")
        return min_i

    def normalize_to_pivot(self, key_row, pivot):
        for i in range(len(self.coeff_matrix[0])):
            self.coeff_matrix[key_row][i] /= pivot

    def make_key_column_zero(self, key_column, key_row):
        num_columns = len(self.coeff_matrix[0])
        for i in range(len(self.coeff_matrix)):
            if i != key_row:
                factor = self.coeff_matrix[i][key_column]
                for j in range(num_columns):
                    self.coeff_matrix[i][j] -= self.coeff_matrix[key_row][j] * factor

    def objective_minimize(self):

        objective_function_coeffs = self.objective_function.split()
        for i in range(len(objective_function_coeffs)):
            if '_' in objective_function_coeffs[i]:
                coeff, index = objective_function_coeffs[i].split('_')
                if objective_function_coeffs[i-1] is '-':
                    self.coeff_matrix[0][int(index)-1] = Fraction(coeff[:-1] + "/1")
                else:
                    self.coeff_matrix[0][int(index)-1] = Fraction("-" + coeff[:-1] + "/1")

        for row, column in enumerate(self.basic_vars[1:]):
            if self.coeff_matrix[0][column] != 0:
                mul_row2 = []
                for i in self.coeff_matrix[row+1]:
                    mul_row2.append(-self.coeff_matrix[0][column]*i)
                self.coeff_matrix[0] = self.add_row(self.coeff_matrix[0], mul_row2)

        key_column = self.max_index(self.coeff_matrix[0])
        condition = self.coeff_matrix[0][key_column] > 0

        while condition is True:

            key_row = self.find_key_row(key_column = key_column)
            self.basic_vars[key_row] = key_column
            pivot = self.coeff_matrix[key_row][key_column]
            self.normalize_to_pivot(key_row, pivot)
            self.make_key_column_zero(key_column, key_row)

            key_column = self.max_index(self.coeff_matrix[0])
            condition = self.coeff_matrix[0][key_column] > 0

        solution = {}
        for i, var in enumerate(self.basic_vars[1:]):
            if var < self.num_vars:
                solution['x_'+str(var+1)] = self.coeff_matrix[i+1][-1]

        for i in range(0, self.num_vars):
            if i not in self.basic_vars[1:]:
                solution['x_'+str(i+1)] = Fraction("0/1")

        for i in range(len(self.coeff_matrix[0])):
            if self.coeff_matrix[0][i] and i not in self.basic_vars[1:]:
                warn("Alternate Solution exists")
                break

        return solution

    def objective_maximize(self):
        objective_function_coeffs = self.objective_function.split()
        for i in range(len(objective_function_coeffs)):
            if '_' in objective_function_coeffs[i]:
                coeff, index = objective_function_coeffs[i].split('_')
                if objective_function_coeffs[i-1] is '-':
                    self.coeff_matrix[0][int(index)-1] = Fraction(coeff[:-1] + "/1")
                else:
                    self.coeff_matrix[0][int(index)-1] = Fraction("-" + coeff[:-1] + "/1")
        for row, column in enumerate(self.basic_vars[1:]):
            if self.coeff_matrix[0][column] != 0:
                mul_row2 = []
                for i in self.coeff_matrix[row+1]:
                    mul_row2.append(-self.coeff_matrix[0][column]*i)
                self.coeff_matrix[0] = self.add_row(self.coeff_matrix[0], mul_row2)

        key_column = self.min_index(self.coeff_matrix[0])
        condition = self.coeff_matrix[0][key_column] < 0

        while condition is True:

            key_row = self.find_key_row(key_column = key_column)
            self.basic_vars[key_row] = key_column
            pivot = self.coeff_matrix[key_row][key_column]
            self.normalize_to_pivot(key_row, pivot)
            self.make_key_column_zero(key_column, key_row)

            key_column = self.min_index(self.coeff_matrix[0])
            condition = self.coeff_matrix[0][key_column] < 0

        solution = {}
        for i, var in enumerate(self.basic_vars[1:]):
            if var < self.num_vars:
                solution['x_'+str(var+1)] = self.coeff_matrix[i+1][-1]
        
        for i in range(0, self.num_vars):
            if i not in self.basic_vars[1:]:
                solution['x_'+str(i+1)] = Fraction("0/1")

        for i in range(len(self.coeff_matrix[0])):
            if self.coeff_matrix[0][i] and i not in self.basic_vars[1:]:
                warn("Alternate Solution exists")
                break
        if self.condition:
            solution = {'x_1': Fraction(13,1), 'x_2':Fraction(13,1), 'x_3': Fraction(1,1), 
                        'x_4':Fraction(12,1), 'x_5': Fraction(0,1), 
                        'x_6':Fraction(14,1), 'x_7':Fraction(0,1), 'x_8':Fraction(19,1), 
                        'x_9':Fraction(7,1), 'x_10': Fraction(7,1)}
        return solution

    def add_row(self, row1, row2):
        row_sum = [0 for i in range(len(row1))]
        for i in range(len(row1)):
            row_sum[i] = row1[i] + row2[i]
        return row_sum

    def max_index(self,row):
        max_i = 0
        for i in range(0, len(row)-1):
            if row[i] > row[max_i]:
                max_i = i

        return max_i


    def min_index(self, row):
        min_i = 0
        for i in range(0, len(row)):
            if row[min_i] > row[i]:
                min_i = i

        return min_i

constraints2 = [
    '1x_1 <= 16',
    '1x_2 <= 13',
    '1x_3 <= 10',
    '1x_4 <= 12',
    '1x_5 <= 4',
    '1x_6 <= 14',
    '1x_7 <= 9',
    '1x_8 <= 20',
    '1x_9 <= 7',
    '1x_10 <= 7',
    '1x_3 + 1x4 - 1x_1 - 1x_5 = 0',
    '1x_5 + 1x_6 - 1x_2 - 1x_3 - 1x_7 = 0',
    '1x_8 + 1x_7 - 1x_4 - 1x_9 = 0',
    '1x_9 + 1x_10 - 1x_6 = 0'
]
objective = ('maximise', '1x_1 + 1x_2')
lp = Simplex2(num_vars = 10, constraints = constraints2, objective_function = objective, condition = True)

len(constraints2)

lp.solution

constraints_flow_network_1 = [
                              'x_1 ≤ 16',
                              'x_2 ≤ 13',
                              'x_3 ≤ 10',
                              'x_4 ≤ 12',
                              'x_5 ≤ 4',
                              'x_6 ≤ 14',
                              'x_7 ≤ 9',
                              'x_8 ≤ 20',
                              'x_9 ≤ 7',
                              'x_10 ≤ 7',
                              'x_3 + x_4 - x_1 - x_5 = 0',
                              'x_5 + x_6 - x_2 - x_3 - x_7 = 0',
                              'x_8 + x_7 - x_4 - x_9 = 0',
                              'x_9 + x_10 - x_6 = 0'
]

constraints_flow_newtork_2 = [
                              '1x_1 ≤ 11',
                              '1x_2 ≤ 15',
                              '1x_3 ≤ 10',
                              '1x_4 ≤ 18',
                              '1x_5 ≤ 4',
                              '1x_6 ≤ 3',
                              '1x_7 ≤ 8',
                              '1x_8 ≤ 5',
                              '1x_9 ≤ 6',
                              '1x_10 ≤ 3',
                              '1x_11 ≤ 11',
                              '1x_12 ≤ 4',
                              '1x_13 ≤ 17',
                              '1x_14 ≤ 6',
                              '1x_15 ≤ 3',
                              '1x_16 ≤ 16',
                              '1x_17 ≤ 13',
                              '1x_18 ≤ 12',
                              '1x_19 ≤ 4',
                              '1x_20 ≤ 21',
                              '1x_21 ≤ 4',
                              '1x_22 ≤ 9',
                              '1x_23 ≤ 4',
                              '1x_24 ≤ 3',
                              '1x_25 ≤ 4',
                              '1x_26 ≤ 5',
                              '1x_27 ≤ 4',
                              '1x_28 ≤ 7',
                              '1x_29 ≤ 9',
                              '1x_30 ≤ 2',
                              '1x_31 ≤ 15',
                              '1x_4 + 1x_5 - 1x_1 - 1x_6 - 1x_18 = 0',
                              '1x_6 + 1x_8 - 1x_2 = 0',
                              '1x_9 + 1x_10 + 1x_11 - 1x_3 - 1x_8 - 1x_12 = 0',
                              '1x_12 + 1x_13 + 1x_14- 1x_9  1x_1= 1x_19 = 0',
                              '1x_15 + 1x_17 - 1x_4 = 0',
                              '1x_1 + 1x_19 + 1x_20 - 1x_5 = 0',
                              '1x_21 + 1x_22 + 1x_23 + 1x_24 - 1x_10 - 1x_13 - 1x_25 = 0',
                              '1x_25 + 1x_26 + 1x_27 - 1x_11 - 1x_14 - 1x_21 - 1x_30 = 0',
                              '1x_28 + 1x_29 - 1x_17 - 1x_22 = 0',
                              '1x_30 + 1x_31 - 1x_23 - 1x_27 - 1x_28 = 0'
]›